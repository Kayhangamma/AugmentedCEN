package main;
//Code Author: Naman Mody

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import au.com.bytecode.opencsv.CSVWriter;

import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Row;


public class ResolutionGenerator {


	public static Set<Integer> badRows = new HashSet<Integer>();
	
	public static void extractResolution(String filePath, File F, String[] fields){
		
		ArrayList<String> resols = new ArrayList<String>();
		
		try{
			
			FileInputStream file = new FileInputStream(new File(filePath));
			
			HSSFWorkbook wb = new HSSFWorkbook(file);		
			wb.setMissingCellPolicy(Row.RETURN_BLANK_AS_NULL);
			HSSFSheet sheet = wb.getSheetAt(0);
			
			int numrows = sheet.getPhysicalNumberOfRows();			
			HSSFRow curr_row = sheet.getRow(0);
			
			@SuppressWarnings("unused")
			int numcells = curr_row.getPhysicalNumberOfCells();		
			
			
			if(checkForError(curr_row, fields)) {
				
				System.err.println("Field descriptions are incorrect or absent. The input file may be corrupt.") ;
				System.exit(0);
			}
		
			
			 
			ArrayList<Integer> pivots = getPivots(curr_row, fields);
			//System.out.println("pivots are " + pivots.size());			
			System.out.println("rows are " + numrows);		
			
			for (int j=1; j<=numrows-1; j++) {
				
				curr_row = sheet.getRow(j);
				
				//if (curr_row==null) System.out.println("row is null here"); 
				if(getJoinedString(curr_row, j, pivots)!=null) resols.add(getJoinedString(curr_row, j, pivots));
				
			}
			
			
		
			//Converting resolution to array for writing 
			String[] resolutions = new String[resols.size()];
			resolutions = resols.toArray(resolutions);		
			writeCSVFile(resolutions, F);	
			
		} 
		
		catch (FileNotFoundException e) {
	    e.printStackTrace();
		}
		
		catch (IOException e) {
		    e.printStackTrace();
		    		    
		}			
	}
	
	public static ArrayList<Integer> getPivots(HSSFRow c_row, String[] fields){
		
		ArrayList<Integer> pivotList = new ArrayList<Integer>();
		int num_of_cells = c_row.getPhysicalNumberOfCells();
		
		
		for (String f: fields) {
			
			
			for (int i=0; i<num_of_cells; i++) {
								
				HSSFCell cell = c_row.getCell(i);
				if (cell.getCellType()==HSSFCell.CELL_TYPE_STRING) {
					
					if (cell.getStringCellValue().equalsIgnoreCase(f)) pivotList.add(i);
				}
			
			}		
		}
		
		//for (int x: pivotList) System.out.println(x);		
		return pivotList;
		
	}

	public static String getJoinedString(HSSFRow curr_row, int curr_num, ArrayList<Integer> pivots){
		
		int n=0;	
		HSSFCell cell = null;
		boolean[] checkContent = new boolean[pivots.size()];
			
		StringBuilder joined = new StringBuilder();
		
		if (curr_row==null) {badRows.add(curr_num); return null; }
		//System.out.println("pivots number " + pivots.get(0));
				
				for (n=0; n<pivots.size(); n++) {
							
					
					cell = curr_row.getCell(pivots.get(n));
					if (cell==null) { 
						}
					
					
					else {
						
					//System.out.println("current row is " + curr_num);
						joined.append(getContents(cell));
						joined.append(" ");
						checkContent[n]=true;
						
					}
					
					
					
					/**try{
						
						joined.append(curr_row.getCell(pivots.get(n)).getStringCellValue());
						joined.append(" #? ");				
					
				
						joined.append(curr_row.getCell(pivots.get(n)).getStringCellValue());	
			
					}
					
					catch (NullPointerException e) {System.out.println("Exception at" + curr_num);
					
					} **/
			
			
			}
				
		if (!(Arrays.toString(checkContent).contains("true"))) { 
			
			badRows.add(curr_num); return null; }
		
		return joined.toString().trim();
		
		
	}
	
	public static String getContents(HSSFCell cell){

		switch(cell.getCellType()){
		
		
		case HSSFCell.CELL_TYPE_NUMERIC:			
			return Double.toString(cell.getNumericCellValue());
			
		case HSSFCell.CELL_TYPE_STRING:
			return cell.getStringCellValue();
			
		default:
			return " ";
		}
	}
	
	
	public static void writeCSVFile(String[] rList, File F) throws IOException{
		
		//System.out.println("rList has " + rList.length);
	
		
		List<String[]> sArrs = new ArrayList<String[]>();
	
		for (int k=0; k<rList.length; k++) {			
			sArrs.add(new String[] {rList[k]});
			
		}
		
		CSVWriter writer = new CSVWriter(new FileWriter(F.getParent()+"\\Autogenerated--"+OptinalArguments.currentTime+ "\\AllMerged.csv"), '\n');

		writer.writeAll(sArrs);
		writer.close();
		//writer.writeNext(rList);
		//writer.close();
		
			 
	}
	
	public static boolean checkForError(HSSFRow c_row, String[] fields){
		
		
		int headings = c_row.getPhysicalNumberOfCells();
		if (headings<fields.length) return false; 
		
		
		boolean[] present = new boolean[fields.length];
		
		for (int a=0; a<fields.length; a++){
			
			for (int i=0; i<headings; i++) {
				
				if (c_row.getCell(i).getStringCellValue().equalsIgnoreCase(fields[a])) {
					
					present[a]=true;
					break;
				}
			}
		}
		
		
			
		if (Arrays.toString(present).contains("false")) return true;
		
		else return false;
		
	}
	

}